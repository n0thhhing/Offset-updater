import * as fs from 'fs';

const isRegExp = (obj: any): obj is RegExp => obj instanceof RegExp;
const hLib = await readHex('libs/new.so');
const patterns = [
  'f5 53 be a9 f3 7b 01 a9 ?? ?? ?? ?? ?? ?? ?? 39 f3 03 01 2a f4 03 00 aa ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? 28 00 80 52 ?? ?? ?? 39 e0 03 14 aa ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? b9 1f 01 13 6b ?? ?? ?? ?? e0 03 14 aa ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 e1 03 13 2a 02 01 40 f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 91 e1 03 1f aa ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 00 00 80 12 ?? ?? ?? ?? c0 03 5f d6 ?? ?? ?? ?? e9 23 bb 6d f9 63 01 a9 f7 5b 02 a9 f5 53 03 a9 f3 7b 04 a9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? 39 ?? ?? ?? f9 f4 03 00 aa ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9 ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? f9',
];
async function readHex(filePath: FilePath): Promise<Hex> {
  const start: Time = Bun.nanoseconds();
  try {
    const data: Buffer = await fs.promises.readFile(filePath);
    const hexString: Hex = data.toString('hex');
    const end: Time = Bun.nanoseconds();
    console.log(`readHex(${filePath}) ${(end - start) / 1_000_000}`);
    return hexString;
  } catch (err) {
    throw err;
  }
}

const processPattern = (pattern: Pattern): RegExp => {
  const start: Time = Bun.nanoseconds();
  const newPattern: RegExp = new RegExp(
    pattern
      .replace(/\s+|\?/g, (char) => (char === '?' ? '.' : ''))
      .toLowerCase(),
    'g',
  );
  console.log('processPattern:', (Bun.nanoseconds() - start) / 1_000_000);
  return newPattern;
};

function scan(pattern: RegExp | Pattern, hexString: Hex): Offset[] {
  const start: Time = Bun.nanoseconds();
  if (!isRegExp(pattern)) pattern = processPattern(pattern);
  const matchesIndexes: number[] = [];
  let match;
  while ((match = pattern.exec(hexString)) !== null) {
    matchesIndexes.push(match.index / 2);
  }
  const end: Time = Bun.nanoseconds();
  console.log('scan()', (end - start) / 1_000_000);
  return matchesIndexes;
}

function strSearch(pattern, hexString) {
  const matches = [];
  let index = hexString.search(pattern);
  let offset = 0;
  while (index !== -1) {
    matches.push(index / 2);
    offset += index + 2;
    const remainingString = hexString.slice(offset);
    index = remainingString.search(pattern);
  }
  return matches;
}

for (const pattern of patterns) {
  const start: Time = Bun.nanoseconds();
  const matches: string[] = scan(pattern, hLib).map(
    (index: number) => `0x${index.toString(16)}`,
  );
  console.log(
    'Pattern found at positions:',
    matches,
    (Bun.nanoseconds() - start) / 1_000_000,
  );
}
